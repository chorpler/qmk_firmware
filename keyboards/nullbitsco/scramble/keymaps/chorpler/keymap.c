/*
Copyright 2021 Jay Greco

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include QMK_KEYBOARD_H

#define _BASE 0

enum scramble_keycodes {
  NXMODE, // Next Unicode mode
  SHRUG,  // ¬Ø\_(„ÉÑ)_/¬Ø
  TFLIP,  // (‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª
  POOP,   // üí©
  DPOINT, // (‡≤†_‡≤†)
  STRUT   // ·ïï( ·êõ )·ïó
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

// [_BASE] = LAYOUT(
//     KC_F13, KC_F14, KC_F15,
//     KC_F16, KC_F17, KC_F18
// )

// [_BASE] = LAYOUT(
//     KC_F13, DPOINT, STRUT,
//     POOP, SHRUG, TFLIP
// )

// [_BASE] = LAYOUT(
//     UC_M_WC, UC_M_LN, UC_M_MA,
//     POOP, TFLIP, SHRUG
// )

// [_BASE] = LAYOUT(
//     LCTL(KC_SPC), DPOINT, STRUT,
//     POOP, TFLIP, SHRUG
// )

[_BASE] = LAYOUT(
    LCTL(KC_SPC), DPOINT, STRUT,
    UC_MOD, TFLIP, SHRUG
)

};


bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
        // case LOWER:
        //   if (record->event.pressed) {
        //     layer_on(_LOWER);
        //     update_tri_layer(_LOWER,  _RAISE,  _ADJUST);
        //   } else {
        //     layer_off(_LOWER);
        //     update_tri_layer(_LOWER,  _RAISE,  _ADJUST);
        //   }
        //   return false;
        //   break;
        // case RAISE:
        //   if (record->event.pressed) {
        //     layer_on(_RAISE);
        //     update_tri_layer(_LOWER,  _RAISE,  _ADJUST);
        //   } else {
        //     layer_off(_RAISE);
        //     update_tri_layer(_LOWER,  _RAISE,  _ADJUST);
        //   }
        //   return false;
        //   break;
        case SHRUG:
          if (record->event.pressed) {
            // set_unicode_input_mode(UC_MAC);
            send_unicode_string("¬Ø\\_(„ÉÑ)_/¬Ø");
          }
          return false;
          break;
        case TFLIP:
          if (record->event.pressed) {
            send_unicode_string("(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // set_unicode_input_mode(UC_MAC);
            // send_unicode_string("(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // send_unicode_string("(‚ïØ‚ó¶‚ñ°‚ó¶)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // send_unicode_string("(‚ïØ‚çú‚ñ°‚çú)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // send_unicode_string("(‚ïØ‚äó‚ñ°‚äó)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // send_unicode_string("(‚ïØ‚óè‚ñ°‚óè)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // send_unicode_string("(‚ïØ‚óç‚ñ°‚óç)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // send_unicode_string("(‚ïØ‚äô‚ñ°‚äô)‚ïØÔ∏µ ‚îª‚îÅ‚îª");
            // send_unicode_string("(‚ïØ");
            // _delay_ms(30);
            // send_unicode_string("¬∞");
            // send_unicode_string("‚ó¶");
            // send_unicode_string("‚óã");
            // send_unicode_string("‚çú");
            // send_unicode_string("¬∞");
            // send_unicode_string("‚äô");
            // _delay_ms(30);
            // send_unicode_string("‚ñ°");
            // _delay_ms(30);
            // send_unicode_string("‚äô");
            // _delay_ms(30);
            // send_unicode_string("Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª");
          }
          return false;
          break;
        case POOP:
          if (record->event.pressed) {
            // set_unicode_input_mode(UC_MAC);
            send_unicode_string("üí©");
          }
          return false;
          break;
        case DPOINT:
          if (record->event.pressed) {
            // set_unicode_input_mode(UC_MAC);
            send_unicode_string("(‡≤†_‡≤†)");
            // send_unicode_string("(‡≤∞_‡≤∞)");
            // send_unicode_string("(");
            // _delay_ms(30);
            // // send_string("‡≤†");
            // send_unicode_string("‡≤∞");
            // _delay_ms(30);
            // send_unicode_string("_");
            // _delay_ms(30);
            // send_string("‡≤∞");
            // _delay_ms(30);
            // send_unicode_string(")");
          }
          return false;
          break;
        case STRUT:
          if (record->event.pressed) {
            // set_unicode_input_mode(UC_MAC);
            send_unicode_string("·ïï( ·êõ )·ïó");
          }
          return false;
          break;
      }
    return true;
};



#ifdef OLED_ENABLE
static void render_logo(void) {
    static const char PROGMEM nullbits_logo[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xf6, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xe4, 0xfe, 0xff, 0xfe, 0xf4, 0x00,
        0x00, 0x00, 0x00, 0xfe, 0xff, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xe0, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
        0xe0, 0xe0, 0xe0, 0x00, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xc0, 0xe0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xe0, 0xe0, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xe0, 0xe0, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0xc3, 0xe3, 0xe3, 0xc3, 0x00, 0x00, 0xc0, 0xe0, 0xe0, 0xfe, 0xfe,
        0xff, 0xfe, 0xe0, 0xe0, 0xe0, 0xc0, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xe0, 0xe0, 0xe0,
        0xc0, 0xe0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0x00, 0x01, 0x01, 0x01, 0x03, 0x03, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x03, 0x03, 0x07, 0x0f, 0xff, 0xff, 0xfe,
        0xfc, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0x01, 0x01, 0xff, 0xff,
        0xff, 0xff, 0x01, 0x01, 0x01, 0x01, 0x00, 0x1e, 0x3f, 0x7f, 0xff, 0xfb, 0xf3, 0xf1, 0xe1, 0xe1,
        0xe1, 0xc1, 0x81, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x0f, 0x3f, 0x7f, 0xff, 0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0x7f, 0x3f, 0x1f, 0x00, 0x00,
        0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0x00,
        0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x7f, 0xf0, 0xf0, 0xf0, 0xf8, 0x78, 0x7e, 0x3f, 0x3f, 0x1f,
        0x07, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xfb,
        0x7f, 0x7f, 0x3f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    oled_write_raw_P(nullbits_logo, sizeof(nullbits_logo));
}

bool oled_task_user(void) {
    render_logo();
    return false;
}
#endif

void matrix_init_user(void) {
  set_scramble_LED(LED_OFF);
}

bool encoder_update_user(uint8_t index, bool clockwise) {
    if (clockwise) {
        tap_code(KC_VOLU);
    } else {
        tap_code(KC_VOLD);
    }
    return true;
}
